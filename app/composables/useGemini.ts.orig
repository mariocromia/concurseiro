/**
 * Gemini AI Direct Connection Composable
 *
 * Conexão direta com Google Gemini API
 * Elimina proxy server-side para resolver erros 503
 *
 * @author Claude Code
 * @version 2.0 - Direct Connection
 */

import { GoogleGenerativeAI } from '@google/generative-ai'

export const useGemini = () => {
  const config = useRuntimeConfig()
  const supabase = useSupabaseClient()
  const user = useSupabaseUser()
  const loading = ref(false)
  const error = ref<string | null>(null)

  // Inicializar Google AI apenas se API key estiver configurada
  let genAI: GoogleGenerativeAI | null = null

  if (config.public.googleAiApiKey) {
    genAI = new GoogleGenerativeAI(config.public.googleAiApiKey as string)
  }

  /**
   * Verificar se usuário tem acesso Pro
   */
  const hasProAccess = async (): Promise<boolean> => {
    try {
      if (!user.value) {
        console.log('[useGemini] No user logged in')
        return false
      }

      // Verificar na tabela users
      const { data, error: fetchError } = await supabase
        .from('users')
        .select('subscription_type, trial_ends_at')
        .eq('id', user.value.id)
        .single()

      if (fetchError) {
        console.error('[useGemini] Error fetching user data:', fetchError)
        return false
      }

      // Verificar se é Pro ou tem trial ativo
      const isProUser = (data as any)?.subscription_type === 'pro'
      const hasActiveTrial = (data as any)?.trial_ends_at && new Date((data as any).trial_ends_at) > new Date()

      console.log('[useGemini] Access check:', {
        userId: user.value.id,
        isProUser,
        hasActiveTrial,
        hasAccess: isProUser || hasActiveTrial
      })

      return isProUser || hasActiveTrial || false
    } catch (err) {
      console.error('[useGemini] Error checking Pro access:', err)
      return false
    }
  }

  /**
   * Rate limiting simples no frontend
   */
  const checkRateLimit = (): boolean => {
    const key = `ai_requests_${user.value?.id || 'anon'}`
    const now = Date.now()
    const hour = 60 * 60 * 1000

    // Recuperar dados do localStorage
    const stored = localStorage.getItem(key)
    let data = stored ? JSON.parse(stored) : { count: 0, resetAt: now + hour }

    // Reset se passou 1 hora
    if (now > data.resetAt) {
      data = { count: 0, resetAt: now + hour }
    }

    // Verificar limite (20 por hora)
    if (data.count >= 20) {
      const minutesLeft = Math.ceil((data.resetAt - now) / 60000)
      error.value = `Limite de 20 requisições por hora atingido. Aguarde ${minutesLeft} minutos.`
      return false
    }

    // Incrementar contador
    data.count++
    localStorage.setItem(key, JSON.stringify(data))

    return true
  }

  /**
   * Gerar conteúdo genérico
   */
  const generateContent = async (
    prompt: string,
    options: {
      model?: string
      temperature?: number
      maxTokens?: number
      systemInstruction?: string
    } = {}
  ): Promise<string> => {
    loading.value = true
    error.value = null

    try {
      // Verificar se API key está configurada
      if (!genAI) {
        throw new Error('Google AI não está configurado. Verifique a API key.')
      }

      // Verificar acesso Pro
      if (!(await hasProAccess())) {
        throw new Error('Recursos de IA disponíveis apenas no plano Pro. Faça upgrade para desbloquear.')
      }

      // Verificar rate limit
      if (!checkRateLimit()) {
        throw new Error(error.value || 'Limite de requisições atingido')
      }

      // Configurar modelo
      const model = genAI.getGenerativeModel({
        model: options.model || 'gemini-2.0-flash-exp',
        generationConfig: {
          temperature: options.temperature || 0.7,
          maxOutputTokens: options.maxTokens || 2048,
        },
        systemInstruction: options.systemInstruction
      })

      console.log('[useGemini] Generating content with prompt length:', prompt.length)

      // Gerar conteúdo
      const result = await model.generateContent(prompt)
      const response = result.response
      const text = response.text()

      console.log('[useGemini] Response received, length:', text.length)

      return text
    } catch (err: any) {
      console.error('[useGemini] Error generating content:', err)
      error.value = err.message || 'Erro ao gerar conteúdo'
      throw err
    } finally {
      loading.value = false
    }
  }

  /**
   * Gerar exercícios
   */
  const generateExercises = async (
    content: string,
    quantity: number = 5,
    difficulty: string = 'medium',
    chapterTitle: string = 'Conteúdo'
  ) => {
    const difficultyMap: Record<string, string> = {
      easy: 'fácil',
      medium: 'médio',
      hard: 'difícil'
    }

    const prompt = `Você é um professor experiente criando exercícios de múltipla escolha.

Baseado no seguinte conteúdo sobre "${chapterTitle}":
${content.substring(0, 3000)}

Crie EXATAMENTE ${quantity} questões de múltipla escolha de nível ${difficultyMap[difficulty] || difficulty}.

IMPORTANTE: Retorne APENAS um JSON válido no seguinte formato, sem nenhum texto antes ou depois:
{
  "exercises": [
    {
      "question": "Pergunta completa aqui",
      "options": {
        "A": "Primeira opção",
        "B": "Segunda opção",
        "C": "Terceira opção",
        "D": "Quarta opção"
      },
      "correct_answer": "A",
      "explanation": "Explicação da resposta correta"
    }
  ]
}

Requisitos:
- Cada questão deve ter exatamente 4 opções (A, B, C, D)
- Apenas uma resposta correta por questão
- Questões devem ser relevantes ao conteúdo fornecido
- Explicações devem ser claras e educativas
- Retorne APENAS o JSON, sem markdown ou outros textos`

    try {
      const text = await generateContent(prompt, { temperature: 0.8 })

      // Extrair JSON da resposta
      let jsonStr = text
      jsonStr = jsonStr.replace(/```json\s*/gi, '').replace(/```\s*/g, '')

      const jsonMatch = jsonStr.match(/\{[\s\S]*\}/)
      if (!jsonMatch) {
        throw new Error('Resposta da IA não contém JSON válido')
      }

      const parsed = JSON.parse(jsonMatch[0])
      const exercises = parsed.exercises || parsed

      if (!Array.isArray(exercises)) {
        throw new Error('Formato de exercícios inválido')
      }

      // Validar cada exercício
      return exercises.map((ex: any, index: number) => {
        if (!ex.question) throw new Error(`Exercício ${index + 1} sem pergunta`)
        if (!ex.options) throw new Error(`Exercício ${index + 1} sem opções`)
        if (!ex.correct_answer) throw new Error(`Exercício ${index + 1} sem resposta`)

        return {
          question: ex.question,
          options: ex.options,
          correct_answer: ex.correct_answer,
          explanation: ex.explanation || ''
        }
      })
    } catch (err: any) {
      console.error('[useGemini] Error generating exercises:', err)
      throw err
    }
  }

  /**
   * Gerar resumo
   */
  const generateSummary = async (
    content: string,
    style: 'detailed' | 'concise' | 'topics' = 'concise'
  ): Promise<string> => {
    const styleMap = {
      detailed: 'resumo detalhado com explicações completas',
      concise: 'resumo conciso com pontos principais',
      topics: 'lista de tópicos principais em bullet points'
    }

    const prompt = `Crie um ${styleMap[style]} do seguinte conteúdo:

${content.substring(0, 5000)}

Formato: Markdown bem estruturado em português brasileiro.`

    return await generateContent(prompt, { temperature: 0.5 })
  }

  /**
   * Gerar flashcards
   */
  const generateFlashcards = async (
    content: string,
    quantity: number = 10,
    topic: string = 'Conteúdo'
  ) => {
    const prompt = `Baseado no conteúdo sobre "${topic}", crie ${quantity} flashcards.

Conteúdo:
${content.substring(0, 3000)}

Retorne APENAS um JSON válido:
{
  "flashcards": [
    {
      "front": "Pergunta ou conceito",
      "back": "Resposta ou explicação",
      "category": "Categoria do card"
    }
  ]
}`

    try {
      const text = await generateContent(prompt, { temperature: 0.7 })

      const jsonMatch = text.match(/\{[\s\S]*\}/)
      if (!jsonMatch) throw new Error('Resposta inválida')

      const parsed = JSON.parse(jsonMatch[0])
      const flashcards = parsed.flashcards || parsed

      if (!Array.isArray(flashcards)) throw new Error('Formato inválido')

      return flashcards.map((card: any) => ({
        front: card.front || '',
        back: card.back || '',
        category: card.category || topic
      }))
    } catch (err: any) {
      console.error('[useGemini] Error generating flashcards:', err)
      throw err
    }
  }

  /**
   * Chat com tutor IA
   */
  const sendMessage = async (
    message: string,
    context?: string
  ): Promise<string> => {
    const systemInstruction = context ||
      'Você é um tutor educacional brasileiro especializado em concursos e vestibulares. ' +
      'Responda de forma clara, didática e em português do Brasil. ' +
      'Use exemplos práticos e seja encorajador.'

    return await generateContent(message, {
      systemInstruction,
      temperature: 0.7,
      maxTokens: 1024
    })
  }

  /**
   * Gerar mapa mental
   */
  const generateMindMap = async (
    content: string,
    title: string = 'Mapa Mental'
  ) => {
    const prompt = `Crie um mapa mental sobre "${title}" baseado no conteúdo:

${content.substring(0, 3000)}

Retorne APENAS um JSON válido com a estrutura hierárquica:
{
  "title": "${title}",
  "nodes": [
    {
      "id": "1",
      "text": "Conceito Principal",
      "children": [
        {
          "id": "1.1",
          "text": "Subconceito",
          "children": []
        }
      ]
    }
  ]
}`

    try {
      const text = await generateContent(prompt, { temperature: 0.6 })

      const jsonMatch = text.match(/\{[\s\S]*\}/)
      if (!jsonMatch) throw new Error('Resposta inválida')

      return JSON.parse(jsonMatch[0])
    } catch (err: any) {
      console.error('[useGemini] Error generating mind map:', err)
      throw err
    }
  }

  /**
   * Explicar seleção de texto
   */
  const explainSelection = async (text: string): Promise<string> => {
    const prompt = `Explique de forma clara e didática o seguinte trecho:

"${text}"

Forneça:
1. Explicação do conceito
2. Exemplos práticos
3. Dicas para memorização

Use linguagem acessível em português brasileiro.`

    return await generateContent(prompt, {
      temperature: 0.6,
      maxTokens: 1024
    })
  }

  return {
    loading: readonly(loading),
    error: readonly(error),
    hasProAccess,
    generateContent,
    generateExercises,
    generateSummary,
    generateFlashcards,
    sendMessage,
    generateMindMap,
    explainSelection
  }
}

// Export alternativo para compatibilidade com código existente
export const useGemini = useGeminiDirect